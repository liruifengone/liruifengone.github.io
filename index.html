<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-gcc指令参数集合" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/22/gcc%E6%8C%87%E4%BB%A4%E5%8F%82%E6%95%B0%E9%9B%86%E5%90%88/" class="article-date">
  <time datetime="2020-08-22T09:28:31.196Z" itemprop="datePublished">2020-08-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/22/gcc%E6%8C%87%E4%BB%A4%E5%8F%82%E6%95%B0%E9%9B%86%E5%90%88/">gcc指令参数集</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>-x：设定文件所使用的语言，如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -x c hello.pig</span><br></pre></td></tr></table></figure>

<p>-c：只激活预处理预编译和汇编，只把程序做成obj文件，即.o文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.c</span><br></pre></td></tr></table></figure>

<p>-S：只激活预处理和安逸，就是只把文件编译成为汇编代码，生成.s汇编代码，可以使用文本编辑器查看</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.c</span><br></pre></td></tr></table></figure>

<p>-E：只激活预处理，不生成文件，只需要把它重定向到一个输出文件里面</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c &gt; filename </span><br><span class="line">gcc -E hello.c | more</span><br></pre></td></tr></table></figure>

<p>-o：指定可执行文件名称</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -o test</span><br></pre></td></tr></table></figure>

<p>-i，-include：指定第一个寻找头文件的目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o example hello.c -I /usr/local/include/freetype</span><br></pre></td></tr></table></figure>

<p>-l：指定程序要链接的库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o example hello.c -lpthread -lm</span><br></pre></td></tr></table></figure>

<p>-L：指定库文件所在的路径名称</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -I/home/zhengshuang/tensorflow_c/include -L/home/zhengshuang/tensorflow_c/lib -ltensorflow test.cpp -o test</span><br></pre></td></tr></table></figure>

<p>-Werror：gcc会在所有产生警告的地方停止编译，迫使程序员对自己的代码进行修改。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Werror -o test test.c</span><br></pre></td></tr></table></figure>

<p>-w：不生成任何警告信息</p>
<p>-W：生成所有警告信息</p>
<p>附录：</p>
<p>__attribute__：设置函数属性，变量属性和类型属性</p>
<p>字节对齐：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span>&#123;</span></span><br><span class="line">    <span class="keyword">short</span> b[<span class="number">3</span>];</span><br><span class="line">&#125;__attribute__((aligned(<span class="number">8</span>)));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span>&#123;</span></span><br><span class="line">    <span class="keyword">short</span> b[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注：以上注明了S1的字节对齐为8，则S1的大小为8字节,S2的大小为6字节。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/22/gcc%E6%8C%87%E4%BB%A4%E5%8F%82%E6%95%B0%E9%9B%86%E5%90%88/" data-id="cke858f5o0003r2fiaqq2fue7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux常用命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/22/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="article-date">
  <time datetime="2020-08-22T09:28:21.304Z" itemprop="datePublished">2020-08-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/22/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Linux常用命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>logout,login：登录shell和注销的命令</li>
<li>more，less，head，tail：显示文件内容</li>
<li>ps：展现正在运行的进程的信息</li>
<li>top：提供系统的实时信息</li>
<li>trace：strace常用来跟踪进程执行时的系统调用和所接收的信号</li>
<li>uname：打印静态系统信息</li>
<li>ifconfig：显示以太网卡的配置</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/22/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" data-id="cke858f5k0001r2fi4cb5ei6q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-语言学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/22/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-08-22T08:52:55.664Z" itemprop="datePublished">2020-08-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/22/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">语言学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="Android四大组件"><a href="#Android四大组件" class="headerlink" title="Android四大组件"></a>Android四大组件</h5><ul>
<li>Service<ul>
<li>启动方法：startService，bindService<ul>
<li>onCreate（第一次启动）-&gt;onStartCommand()-&gt;onStart()(这两个方法每次都会调用)-&gt;onDestroy();</li>
</ul>
</li>
<li>bindService<ul>
<li>onCreate（）-&gt;onBind()-&gt;onUnbind()-&gt;onDestroy()(均只调用一次)</li>
</ul>
</li>
</ul>
</li>
<li>Activity<ul>
<li>Standard</li>
<li>SingleTask</li>
<li>SingleInstance</li>
<li>SingleTop</li>
</ul>
</li>
<li>ContentProvider<ul>
<li>数据共享</li>
<li>增删改查</li>
</ul>
</li>
<li>BroadcastReceiver<ul>
<li>两种注册方式<ul>
<li>静态注册，AndroidManifest中注册</li>
<li>动态注册，Context.registerReceiver()，需要反注册</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h5><ul>
<li>原生开发工具包是一组可以让您在Android应用中利用C和c++代码的工具,可用以从您自己的源代码构建,或者利用现有的预构建库.</li>
</ul>
<h5 id="java权限修饰符"><a href="#java权限修饰符" class="headerlink" title="java权限修饰符"></a>java权限修饰符</h5><ul>
<li>private，在同一个类中才能直接访问。</li>
<li>public，都可以访问</li>
<li>不写关键字，（default）在同一个包中能访问</li>
<li>protected，不同包的子类中可以访问</li>
<li>volatile关键字的作用很简单，就是一个线程在对主内存的某一份数据进行更改时，改完之后会立刻刷新到主内存。并且会强制让缓存了该变量的线程中的数据清空，必须从主内存重新读取最新数据。这样一来就保证了可见性</li>
</ul>
<h5 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h5><p>​        浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间，深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针。</p>
<ul>
<li><p>1.当函数的参数为对象时，实参传递给形参的实际上是实参的一个拷贝对象，系统自动通过拷贝构造函数实现；</p>
</li>
<li><p>2.当函数的返回值为一个对象时，该对象实际上是函数内对象的一个拷贝，用于返回函数调用处。</p>
</li>
<li><p>3.浅拷贝带来问题的本质在于析构函数释放多次堆内存，使用std::shared_ptr，可以完美解决这个问题。</p>
</li>
</ul>
<h5 id="String-StringBuilder-StringBuffer"><a href="#String-StringBuilder-StringBuffer" class="headerlink" title="String StringBuilder StringBuffer"></a>String StringBuilder StringBuffer</h5><ul>
<li>String的值是不可变的，这就导致每次对String的操作都会生成新的String对象。</li>
<li>StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</li>
<li>StringBuilder：可变字符序列，效率高，线程不安全。</li>
<li>StringBuffer：可变字符序列，效率低，线程安全。</li>
<li>StringBuffer线程安全是因为这个类中有大量的synchronized关键字修饰。</li>
<li>String在修改多次以后会在内存中留下大量副本内存，极大的影响性能。</li>
</ul>
<h5 id="synchronized关键字与lock"><a href="#synchronized关键字与lock" class="headerlink" title="synchronized关键字与lock"></a>synchronized关键字与lock</h5><ul>
<li>底层原理属于jvm层面、</li>
<li>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</li>
<li>JVM 是通过进入、退出 对象监视器(Monitor) 来实现对方法、同步块的同步的，而对象监视器的本质依赖于底层操作系统的 互斥锁(Mutex Lock) 实现。</li>
</ul>
<h5 id="JAVA底层实现"><a href="#JAVA底层实现" class="headerlink" title="JAVA底层实现"></a>JAVA底层实现</h5><p>图如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/682504-857dabc892cee19c.png" alt="img"></p>
<ul>
<li>Java内存中的可见性，原子性和有序性<ul>
<li>可见性：是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。</li>
<li>原子性：原子是世界上的最小单位，具有不可分割性。在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性。</li>
<li>Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。</li>
<li>当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。<ul>
<li>当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="内部类与静态内部类"><a href="#内部类与静态内部类" class="headerlink" title="内部类与静态内部类"></a>内部类与静态内部类</h5><ul>
<li>静态内部类创建对象的时候，独立于外部类及其对象，就好像它是一个独立的类，可以和外部类一样使用。</li>
<li>内部类创建对象的时候，不能独立于外部类，必须要先创建外部类的对象，然后再用这个对象来new出内部类的对象。</li>
<li>内部类不可以有非常量的静态成员</li>
</ul>
<h5 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h5><ul>
<li>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</li>
<li>不能实例化对象，必须被继承才能使用</li>
<li>一个类只能继承一个抽象类</li>
<li>在JAVA编程语言中接口是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</li>
<li>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</li>
<li>静态方法：静态方法不能访问非静态的数据和方法，因为这两项都依赖于具体的实例，而静态方法在对象实例化之前就已经被JVM装载，而类中的实例变量和实例对象必须在对象开辟堆内存之后才能使用。</li>
</ul>
<h5 id="JAVA多态"><a href="#JAVA多态" class="headerlink" title="JAVA多态"></a>JAVA多态</h5><ul>
<li><p>多态是同一个行为具有多个不同表现形式或形态的能力。多态就是同一个接口，使用不同的实例而执行不同操作，如图所示</p>
</li>
<li><p>多态的实现方式：重写，接口，抽象类和抽象方法。</p>
</li>
<li><p>重写：</p>
<ul>
<li>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！</li>
<li>当需要在子类中调用父类的被重写方法时，要使用 super 关键字。</li>
<li>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</li>
</ul>
</li>
<li><p>注：java里没有虚函数，所有函数都具有虚函数的性质，除非加了final关键字编程非虚函数。</p>
<p>(1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。</p>
<p>(2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。</p>
<p>(3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</p>
</li>
</ul>
<h5 id="malloc的底层实现"><a href="#malloc的底层实现" class="headerlink" title="malloc的底层实现"></a>malloc的底层实现</h5><ul>
<li><p>关于malloc获得的内存空间是否连续：</p>
<p>对于虚拟空间：答案是连续的，malloc()分配后返回空间可以被看做是一块连续的地址</p>
<p>对于物理空间：答案是不连续的，一块连续的内存空间是由若干不连续的物理页面拼凑而成的</p>
</li>
<li><p>malloc分配的内存位于堆 上， malloc通过底层的系统调用brk()（brk()用来标识堆的起始地址）和mmp()实现。</p>
</li>
<li><p>malloc()并不是直接在操作系统申请内存，而是在进程内存空间中申请内存，如果够用，则直接在进程内存空间申请，如果不够用，则会通过系统调用向操作系统申请内存。</p>
</li>
</ul>
<h5 id="iostream"><a href="#iostream" class="headerlink" title="iostream"></a>iostream</h5><ul>
<li><p>cout语句一般格式：</p>
<p>cout&lt;&lt;expression1&lt;&lt;expression2&lt;&lt;expression3…&lt;&lt;expressionn;</p>
</li>
<li><p>cin语句一般格式：</p>
<p>cin&gt;&gt;变量1&gt;&gt;变量2&gt;&gt;变量3&gt;&gt;…..&gt;&gt;变量n;</p>
</li>
<li><p>常用函数：</p>
<p>cin.get();cin.getline();cin.getloc();</p>
</li>
</ul>
<h5 id="C-map和unordered-map"><a href="#C-map和unordered-map" class="headerlink" title="C++  map和unordered_map"></a>C++  map和unordered_map</h5><ul>
<li>map是有序的，二unordered_map是无序的，unordered_map查找更省时。</li>
</ul>
<h5 id="重写和重载"><a href="#重写和重载" class="headerlink" title="重写和重载"></a>重写和重载</h5><ul>
<li>java<ul>
<li>同名的方法如果有不同的参数列表（<strong>参数类型不同、参数个数不同甚至是参数顺序不同</strong>）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但<strong>不能通过返回类型是否相同来判断重载</strong>。</li>
<li>其实就是<strong>在子类中把父类本身有的方法</strong>重新写一遍。子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以<strong>在方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下，</strong> 对方法体进行修改或重写，这就是重写。但要注意<strong>子类函数的访问修饰权限不能少于父类的。</strong></li>
</ul>
</li>
<li>C++<ul>
<li>重载是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。</li>
<li>是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。</li>
</ul>
</li>
</ul>
<h5 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h5><ul>
<li>在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。</li>
<li>代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</li>
<li>数据段：存储程序中已初始化的全局变量和静态变量</li>
<li>bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。</li>
<li>堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。</li>
<li>映射区:存储动态链接库以及调用mmap函数进行的文件映射</li>
<li>栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值</li>
</ul>
<h5 id="虚函数与纯虚函数"><a href="#虚函数与纯虚函数" class="headerlink" title="虚函数与纯虚函数"></a>虚函数与纯虚函数</h5><ul>
<li>纯虚函数没有任何内容，只能被继承，同时有“=0”标识，</li>
<li>构造函数不能是虚函数，因为调用虚函数需要虚指针，但此时类的实例还没有被构造，所以不能是虚函数</li>
<li>析构函数一般是虚函数，但malloc和free不会调用构造/析构函数</li>
</ul>
<h5 id="delete-与delete"><a href="#delete-与delete" class="headerlink" title="delete 与delete[]"></a>delete 与delete[]</h5><p>一个用于删除指针，一个用于删除多个指针数组</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/22/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="cke858f5s0006r2fi1pd91uje" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-通讯与计算机网络笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/22/%E9%80%9A%E8%AE%AF%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-08-22T08:52:55.632Z" itemprop="datePublished">2020-08-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/22/%E9%80%9A%E8%AE%AF%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/">通信原理与计算机网络</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="通信原理与计算机网络"><a href="#通信原理与计算机网络" class="headerlink" title="通信原理与计算机网络"></a>通信原理与计算机网络</h3><h5 id="滤波器算法"><a href="#滤波器算法" class="headerlink" title="滤波器算法"></a>滤波器算法</h5><ul>
<li><p>高斯滤波</p>
</li>
<li><p>巴特沃斯滤波</p>
</li>
<li><p>IIR滤波器（无限冲激响应滤波器）</p>
<ul>
<li><p>直接1型。基本结构。先实现系统函数的零点，再实现极点，需要2N个乘法器和2N个延迟器<br>$$<br>H(z) = \frac{Y(z)}{X(z)} = \frac{\sum^{M}_{k=0}b_k\cdot z^{-k}}{1-\sum^{N}_{k=1}a_k\cdot z^{-k}} = H_1(z)\cdot H_2(z)<br>$$<br><img src="C:\Users\11736\AppData\Roaming\Typora\typora-user-images\image-20200727145013334.png" alt="image-20200727145013334"></p>
</li>
<li><p>直接2型。先实现系统函数的极点，再实现零点。需要N个延迟器和2N个乘法器<br>$$<br>H(z) = \frac{Y(z)}{X(z)} =  H_2(z)\cdot H_1(z)<br>$$<br><img src="C:\Users\11736\AppData\Roaming\Typora\typora-user-images\image-20200727145535362.png" alt="image-20200727145535362"></p>
</li>
<li><p>级联型，并联型</p>
</li>
</ul>
</li>
<li><p>FIR滤波器</p>
<ul>
<li><p>FIR系统仅在 处有N-1阶极点，在其它地方没有极点，有(N-1)个零点分布在有限Z平面内的任何位置上</p>
</li>
<li><p>直接型<br>$$<br>差分方程：y(n) = \sum^{N-1}<em>{k=0}h(k)x(n-k) \<br>系统函数：H(z) = \sum^{N-1}</em>{n=0}h(n)z^{-n}<br>$$</p>
</li>
<li><p>级联型</p>
</li>
<li><p>快速卷积型</p>
</li>
<li><p>线性相位型</p>
</li>
<li><p>频率取样型</p>
</li>
</ul>
</li>
<li><p>FIR与IIR滤波器的区别</p>
<p>IIR滤波器的系统函数是有理分式，其分母多项式对应于反馈电路。因而他是递归结构的；FIR滤波器的系统函数是有限多项式，属于非递归结构</p>
<p>IIR幅频特性精度很高，不是线性相位的，可以应用于对相位信息不敏感的音频信号上；<br>FIR幅频特性精度较之于IIR低，但是线性相位，就是不同频率分量的信号经过FIR滤波器后他们的时间差不变。这是很好的性质</p>
</li>
</ul>
<h5 id="802-3（Ethernet）"><a href="#802-3（Ethernet）" class="headerlink" title="802.3（Ethernet）"></a>802.3（Ethernet）</h5><ul>
<li>星型</li>
</ul>
<h5 id="802-11（wireless-LAN）"><a href="#802-11（wireless-LAN）" class="headerlink" title="802.11（wireless LAN）"></a>802.11（wireless LAN）</h5><ul>
<li><p>802.11数据包类型</p>
<ul>
<li>数据，用来携带更高层次的数据，负责在工作站之间传输数据</li>
<li>管理，管理数据包控制网络的管理功能</li>
<li>控制，控制对物理媒介的访问，如光缆等。</li>
</ul>
</li>
<li><p>802.11协议管理帧</p>
<ul>
<li>数据链路层是一个很靠近底层的通信协议，它使用Bit来表示信息(也使用Bit来标识数据包的开始和结束)，所以数据链路层的协议格式并没有强制要求一个固定的长度，即802.11协议长度是可变的。不同功能的数据帧长度会不一样。这一特性说明mac802.11数据帧显得更加灵活，然而，也会更加复杂。</li>
<li>管理帧包括：beacon帧，探测请求帧，探测响应帧等。控制帧包括：RTS帧，CTS帧，ACK帧，ps-poll帧。</li>
</ul>
</li>
<li><p>四种主要物理组件</p>
<ul>
<li>工作站（Station），指配备无线网络接口的计算设备，即支持802.11的终端设备</li>
<li>接入点（Access Point），具备无线至有线桥接功能的设备称为接入点，提供接入服务并将802.11MAC帧转换为以太网帧。</li>
<li>无线媒介（Wireless Medium），802.11最初标准化了两钟射频物理层和一种红外线物理层</li>
<li>分布式系统（Distribution System），是802.11的逻辑组件，负责将帧传送至目的地，将各个AP连接起来的骨干网络</li>
</ul>
</li>
<li><p>802.11层次和功能</p>
<ul>
<li><p>MAC</p>
<ul>
<li>访问机制，分段，加密</li>
</ul>
</li>
<li><p>MAC管理</p>
<ul>
<li>联盟，鉴权，同步，漫游，MIB管理信息库，电源管理</li>
</ul>
</li>
<li><p>PLCP物理层汇聚协议</p>
<ul>
<li>空闲信道评估信道（载波监听）</li>
</ul>
</li>
<li><p>PMD物理媒介相关</p>
<ul>
<li>调制，编码</li>
</ul>
</li>
<li><p>PHY管理</p>
<ul>
<li>信道管理，MIB管理信息库</li>
</ul>
</li>
<li><p>站点管理</p>
<ul>
<li><p>协调所有管理功能</p>
<p><img src="C:\Users\11736\AppData\Roaming\Typora\typora-user-images\image-20200711162941712.png" alt="image-20200711162941712"></p>
</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\11736\AppData\Roaming\Typora\typora-user-images\image-20200711161655729.png" alt="image-20200711161655729"></p>
</li>
</ul>
<h5 id="OFDM-正交频分复用技术"><a href="#OFDM-正交频分复用技术" class="headerlink" title="OFDM(正交频分复用技术)"></a>OFDM(正交频分复用技术)</h5><ul>
<li><p>采用多个载波，将信道分为多个子信道，将基带码元均匀的分散到每个载波上，降低码元速率，减小码间串扰。</p>
</li>
<li><p>每个子载波满足公式：<br>$$<br>f_k = \frac k {2T_B}<br>$$<br>其中$k$为整数，$T_B$为码元持续时间最小子载频间隔为：<br>$$<br>\Delta f = f_k - f_i = \frac{1}{T_B}<br>$$</p>
</li>
</ul>
<h5 id="MIMO技术"><a href="#MIMO技术" class="headerlink" title="MIMO技术"></a>MIMO技术</h5><ul>
<li><p>典型MIMO系统包含$m$个发送天线和$n$个接收天线，如果定义发送天线$i$和接收天线$j$之前的信道为$h_{ij}$，则可以得到$n\times m$的信道矩阵。<br>$$<br>\begin{bmatrix}<br>\boldsymbol{h_{11}}&amp;\boldsymbol{h_{12}}&amp;\boldsymbol{h_{13}}&amp;\boldsymbol{h_{14}}\<br>\boldsymbol{h_{21}}&amp;\boldsymbol{h_{22}}&amp;\boldsymbol{h_{23}}&amp;\boldsymbol{h_{24}}\<br>\boldsymbol{h_{31}}&amp;\boldsymbol{h_{32}}&amp;\boldsymbol{h_{33}}&amp;\boldsymbol{h_{34}}\<br>\boldsymbol{h_{41}}&amp;\boldsymbol{h_{42}}&amp;\boldsymbol{h_{43}}&amp;\boldsymbol{h_{44}}\<br>\end{bmatrix}<br>$$</p>
</li>
<li><p>当收发天线之间的信道为窄带时不变系统时，可以得到MIMO系统接收信号的表现形式为,其中接收信号$Y$，发送信号$X$，噪声为$n$：<br>$$<br>\boldsymbol{Y = HX+n}<br>$$</p>
</li>
<li><p>MIMO系统的信道容量由以下公式决定：<br>$$<br>C = mlog_2(\frac{n}{m}\times \frac{S}{N})<br>$$<br>其中普通信道的香农公式为：<br>$$<br>C = Blog_2(1+\frac{S}{N})<br>$$<br>以上参数的意义为：C：信道容量（bps)，B：信道的频带宽度，S/N：信噪比，m：发送天线的个数，n：接收天线的个数。</p>
</li>
<li><p>SU-MIMO和MU-MIMO</p>
<p>如果MIMO系统用于增加一个用户的速率，称之为单用户MIMO（SU-MIMO)。多用户MIMO（MU-MIMO）：如果每个独立的数据流分配给不同的用户，称之为多用户。这种模式主要对上行链路有用。从UE的复杂程度和体积来看，每个UE只能有一个发射天线，因此称之为“协同MIMO”</p>
</li>
<li><p>Massive MIMO（大规模天线技术）</p>
<p>传统的MIMO我们称之为2D-MIMO，以8天线为例，实际信号在做覆盖时，只能在水平方向移动，垂直方向是不动的，信号类似一个平面发射出去，而Massive MIMO，是信号水平维度空间基础上引入垂直维度的空域进行利用，信号的辐射状是个电磁波束。所以Massive MIMO也称为3D-MIMO。</p>
</li>
</ul>
<h5 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h5><ul>
<li><p>HTTP简介</p>
<ul>
<li><p>无连接，无连接的含义是限制每次连接只处理一个请求</p>
</li>
<li><p>媒体独立，任何类型的数据都可以通过HTTP发送</p>
</li>
<li><p>无状态，对于事务没有记忆能力</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/11/cgiarch.gif" alt="cgiarch"></p>
</li>
</ul>
</li>
<li><p>常见http状态码</p>
<ul>
<li>200，请求成功</li>
<li>301，资源被永久转移到其他URL</li>
<li>404，请求的资源不存在</li>
<li>500，内部服务器错误</li>
</ul>
</li>
<li><p>HTTP请求方法</p>
<ul>
<li>HTTP1.0，GET，POST，HEAD，<ul>
<li>GET，请求指定页面信息，并返回实体</li>
<li>HEAD，请求指定页面信息的报头</li>
<li>POST，向指定资源提交数据并处理请求，</li>
</ul>
</li>
<li>HTTP1.1新增，OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法</li>
</ul>
</li>
<li><p>HTTPS</p>
<ul>
<li>就是在HTTP的基础上增加了数据加密，是密文传输</li>
<li>HTTPS请求的过程需要CA证书要验证身份以保证客户端请求到服务器端之后，传回的响应是来自于服务器端，而HTTP则不需要CA证书。</li>
<li>对称加密：解密和加密采用相同的加密算法</li>
<li>非对称加密：需要两个秘钥，公有秘钥和私有秘钥。加密秘钥和解密秘钥成对出现。</li>
<li>摘要算法：数字摘要是采用单项Hash函数将需要加密的明文“摘要”成一串固定长度（128位）的密文，这一串密文又称为数字指纹，它有固定的长度，而且不同的明文摘要成密文，其结果总是不同的，而同样的明文其摘要必定一致。“数字摘要“是https能确保数据完整性和防篡改的根本原因</li>
</ul>
</li>
</ul>
<h5 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h5><ul>
<li><p>TCP三次握手四次挥手</p>
<ul>
<li><p>三次握手的过程</p>
<p>1）主机A向主机B发送TCP连接请求数据包，其中包含主机A的初始序列号seq(A)=x。（其中报文中同步标志位SYN=1，ACK=0，表示这是一个TCP连接请求数据报文；序号seq=x，表明传输数据时的第一个数据字节的序号是x）；</p>
<p>2）主机B收到请求后，会发回连接确认数据包。（其中确认报文段中，标识位SYN=1，ACK=1，表示这是一个TCP连接响应数据报文，并含主机B的初始序列号seq(B)=y，以及主机B对主机A初始序列号的确认号ack(B)=seq(A)+1=x+1）</p>
<p>3）第三次，主机A收到主机B的确认报文后，还需作出确认，即发送一个序列号seq(A)=x+1；确认号为ack(A)=y+1的报文；</p>
</li>
<li><p>四次挥手过程</p>
<p>假设主机A为客户端，主机B为服务器，其释放TCP连接的过程如下：<br>1） 关闭客户端到服务器的连接：首先客户端A发送一个FIN，用来关闭客户到服务器的数据传送，然后等待服务器的确认。其中终止标志位FIN=1，序列号seq=u。<br>2） 服务器收到这个FIN，它发回一个ACK，确认号ack为收到的序号加1。<br>3） 关闭服务器到客户端的连接：也是发送一个FIN给客户端。</p>
<p>4） 客户段收到FIN后，并发回一个ACK报文确认，并将确认序号seq设置为收到序号加1。 首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
</li>
</ul>
</li>
<li><p>TCP与UDP</p>
<ul>
<li>TCP面向连接，UDP是无连接的</li>
<li>TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付</li>
<li>TCP 的逻辑通信信道是全双工的可靠信道；UDP 则是不可靠信道</li>
<li>每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信</li>
<li>TCP 面向字节流（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的（不会出现黏包问题）</li>
<li>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）</li>
<li>TCP 首部开销20字节；UDP 的首部开销小，只有 8 个字节</li>
</ul>
</li>
<li><p>TCP可靠的原因：</p>
<ul>
<li>三次握手，超时重传，滑动窗口，拥塞控制。</li>
</ul>
</li>
<li><p>TCP黏包问题</p>
<ul>
<li>TCP是一个面向字节流的传输服务，数据没有边界，可能出现两个数据包黏在一起的情况。</li>
<li>解决：1，发送定长包，2，包头加上包体长度，3，设置边界符号，4，使用更加复杂的应用层协议</li>
</ul>
</li>
<li><p>流量控制</p>
<ul>
<li><p>接收方根据接收窗口的空闲缓存来通知（advertisedWindowSize）发送方控制发送窗口，使得发送方发送的数据量不大于接收方的接收窗口，已达到流量控制的目的。如果接收方read和receive的速度一样快，那么接收窗口发送给advertisedWindowSize的大小为MaxRecvBuffer，发送方获得advertisedWindowSize之后会计算出发送方可以发送数据的EffectiveWindowSize,这个值表征了发送方目前可以发送多少数据。</p>
<p>如果接收方read的速度比recevie的速度慢，就会造成接收窗口的逐渐减小，因此发送方收到的advertisedWindowSize的大小也在减小，当advertisedWindowSize减小到0，说明接受方不能收取任何数据，意味着TCP将发送进程阻塞。</p>
</li>
</ul>
</li>
<li><p>拥塞控制</p>
<ul>
<li><p>拥塞标志：TCP协议认为超时是拥塞的标志</p>
</li>
<li><p>慢启动和快速恢复</p>
<ul>
<li>慢启动：是在网络发生拥塞时，将慢启动阈值置为当前拥塞窗口的一半，拥塞窗口置为1，采用乘性增加性减的方式进行快速启动的方式</li>
<li>快重传：丢包并不意味这拥塞发生，丢包之后等待超时并慢启动这一过程会降低网络性能，如果在丢包之后可以立即解决而不用慢启动则可以避免网络性能的降低。发送方一旦收到三个连续的重复确认，就对相应的报文段立即重传，而不是等待该报文段的超时重传计时器超时再重传。</li>
<li>快恢复：发生丢包之后，快速重传和快速恢复同时发生，快速恢复是指，将慢启动阈值置为当前拥塞窗口的一半，将拥塞窗口置为慢启动阈值+3，并使用加性增的手段。</li>
</ul>
<p><img src="C:\Users\11736\AppData\Roaming\Typora\typora-user-images\image-20200716153632698.png" alt="image-20200716153632698"></p>
</li>
</ul>
</li>
</ul>
<h5 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h5><ul>
<li>在浏览器输入域名时，操作系统检查本地host是否具备网址映射关系，如果有则调用该IP地址映射，完成解析</li>
<li>若本地host没有，则查找本地DNS解析器缓存，</li>
<li>若以上两个都没有，则查找TCP/IP参数中设置的首选DNS服务器，称为本地DNS服务器。若所需查找的域名包含在本地配置资源中，则返回解析结果，此解析具有权威性。若不包含在本地资源配置中，只是在缓存中，则该解析结果不具有权威性</li>
<li>若以上都失效<ul>
<li>若没用转发模式，则将请求发送到13台根DNS，若根DNS没有查到则转发到下一个根DNS，直到查到为止</li>
<li>若使用了转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用的是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机</li>
</ul>
</li>
</ul>
<h5 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h5><ul>
<li>CGI（Common Gateway Interface）公共网关接口，是外部扩展应用程序与 Web 服务器交互的一个标准接口</li>
</ul>
<h5 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h5><ul>
<li>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址</li>
</ul>
<h5 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h5><ul>
<li>ICMP（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</li>
</ul>
<h5 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h5><ul>
<li>IP</li>
<li>ARP</li>
<li>RARP</li>
<li>IGMP</li>
<li>ICMP</li>
</ul>
<h5 id="OSI网络模型"><a href="#OSI网络模型" class="headerlink" title="OSI网络模型"></a>OSI网络模型</h5><ul>
<li><p>MAC层与物理层</p>
<ul>
<li>物理层为数据链路层提供比特流传输服务</li>
<li>数据链路层传输数据帧</li>
</ul>
</li>
<li><p>应用层协议：</p>
<ul>
<li>HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP</li>
</ul>
</li>
<li><p>表示层，会话层</p>
</li>
<li><p>传输层：TCP，UDP</p>
</li>
<li><p>网络层：ICMP，IGMP</p>
</li>
</ul>
<h5 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h5><ul>
<li>NRZ（不归零），1-&gt;高信号，0-&gt;低信号</li>
<li>NRZI（不归零反转），1-&gt;信号跳变，0-&gt;信号保持</li>
<li>Manchester，1-&gt;高到低跳变,0-&gt;低到高跳变</li>
</ul>
<h5 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h5><ul>
<li>循环冗余校验（CRC）</li>
<li>停止等待协议</li>
<li>连续ARQ</li>
<li>滑动窗口协议</li>
</ul>
<h5 id="p2p与e2e"><a href="#p2p与e2e" class="headerlink" title="p2p与e2e"></a>p2p与e2e</h5><ul>
<li>端到端与点到点是针对网络中传输的两端设备间的关系而言的。<ul>
<li>端到端传输指的是在数据传输前，经过各种各样的交换设备，在两端设备问建立一条链路，就僚它们是直接相连的一样，链路建立后，发送端就可以发送数据，直至数据发送完毕，接收端确认接收成功。</li>
<li>点到点系统指的是发送端把数据传给与它直接相连的设备，这台设备在合适的时候又把数据传给与之直接相连的下一台设备，通过一台一台直接相连的设备，把数据传到接收端。</li>
</ul>
</li>
</ul>
<h5 id="MAC层调度算法"><a href="#MAC层调度算法" class="headerlink" title="MAC层调度算法"></a>MAC层调度算法</h5><ul>
<li><p>ZFS调度算法</p>
<ul>
<li><p>ZFS的中心思想是每次增加一个使得总容量最大的用户，直至用户总容量下降或者选满M个用户</p>
</li>
<li><p>注释：U，全体用户集合。$h_u$是用户u的信道增益，$s_i$是第i步选中的用户。$S_i$是第i步迭代以后选择的用户集合，i是已选择用户总数，假设基站的总数为M，总用户数为K（K&gt;M）</p>
</li>
<li><p>算法流程：</p>
<ul>
<li><p>1，初始化<br>$$<br>i= 1 \<br>s_1 = \underset {x \in U}{arg,max,h_uh_u^H}\<br>S_1 = {s_1}<br>$$<br>定义基站和集合$S_1$的用户使用ZFBF编码进行MU-MIMO传输的总容量为$R_{zf}(S_1)_{max}$。</p>
<p>2，当i&lt;M时新增一个用户<br>$$<br>i \longleftarrow i+1 \<br>s_i = \underset{u\in U/ S_{i-1}}{arg , max R_{zf}(S_{i-1}\bigcup {u})}<br>$$<br>​    令$S_i = S_{i-1} \bigcup {s_i}$，集合$S_i$的总容量为$R_{zf}(S_i)_{max}$。如果$R_{zf}(S_i)_{max} &gt; R_{zf}(S_{i-1})<em>{max}$，则继续步骤2新增用户，如果$R</em>{zf}(S_i)<em>{max} \leq R</em>{zf}(S_{i-1})_{max}$则$i \longleftarrow i-1$，进入步骤3用户选择结束阶段。</p>
<p>3，用户选择结束阶段</p>
<p>4，计算ZFBF预编码矩阵和功率分配<br>$$<br>W = H_{S_i}^{H}({H_{S_i}H_{S_i}^H})^{-1}<br>$$</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>SUS</p>
<ul>
<li><p>SUS算法是基于信道垂直偏量的F范数的低复杂度用户选择呢算法。</p>
</li>
<li><p>定义：$S_0$为SUS算法选择的用户集合，$\mathbf{g}_k$，是用户k的信道增益$\mathbf{h}_k$在已选用户集合的信道空间的垂直补空间上的投影,$\pi(i)$是第i轮递推中选中的用户。$T(i)$是第$i$轮地推中的备选用户集合，假设基站天线数为M，用户总数为K，(K&gt;M)，SUS算法流程如下</p>
<ul>
<li><p>步骤1，初始化<br>$$<br>i = 1 \<br>T_1 = {1,2,…,K}\<br>S_0 = \emptyset<br>$$</p>
</li>
<li><p>步骤2，对备选用户集合$T_i$中的每个用户k计算$\mathbf g_k$，即$\mathbf h_k$垂直于子空间$span{\mathbf g_{(1)},\mathbf g_{(2)},…,\mathbf g_{(i-1)}, }$。<br>$$<br>\mathbf g_k = \mathbf h_k - \sum_{j = 1}^{i-1} \frac{\mathbf h_k \mathbf g_{(j)}^H}{||\mathbf g_{(j)}||^2}\mathbf g_{(j)}\<br> = \mathbf h_k (1- \sum_{j = 1}^{i-1} \frac{ \mathbf g_{(j)}^H}{||\mathbf g_{(j)}||^2}\mathbf g_{(j)})<br>$$</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>  备注：当i = 1时，以上公式为$\mathbf g_k = \mathbf h_k$。

* 步骤3，选中第i个用户
  $$
  \pi (i) = \underset&#123;k\in T_&#123;i&#125;&#125;&#123;arg\,max ||\mathbf g_k||&#125; \\
  S_0 \longleftarrow S_0 \bigcup \&#123;\pi (i) \&#125; \\
  \mathbf h_&#123;(i)&#125; = \mathbf h_&#123;\pi(i)&#125; \\
  \mathbf g_&#123;(i)&#125; = \mathbf g_&#123;\pi(i)&#125;
  $$

* 步骤4，如果$S_0 &lt;M$，选择与$\mathbf g_&#123;(i)&#125;$准正交的用户作为下一轮迭代的备选用户
  $$
  T_&#123;i+1&#125; = \&#123; k \in T_i \, ,k\ne \pi (i) | \frac&#123;\mathbf h_k\mathbf g_&#123;(i)&#125;^H&#125;&#123;||\mathbf h_k||\, ||\mathbf g_&#123;(i)&#125;||&#125;&lt;\alpha \&#125; \\
  i \longleftarrow i+1
  $$
  $\alpha$是一个收信道强度，信道相关性，基站天线数M，总用户数K以及总发送功率等多方面因素影响的值。如果$T_&#123;i+1&#125;$非空，而且已选用户集合的势满足$S_0&lt;M$则进入步骤2；否则选择过程结束，输出$S_0$ 为选择服务的用户集合</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/22/%E9%80%9A%E8%AE%AF%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/" data-id="cke858f600008r2fibohk48a5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-算法笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/22/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-08-22T08:52:55.596Z" itemprop="datePublished">2020-08-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/22/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">算法笔记与整理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="面试算法题记录"><a href="#面试算法题记录" class="headerlink" title="面试算法题记录"></a>面试算法题记录</h2><ul>
<li><p>O(n)时间内找出一个无序数组中的元素，该元素比前面的都大，比后面的都小，输出所有该特性的元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">g_fPrintThePivotElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = data.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rightMin</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    rightMin[n<span class="number">-1</span>] = data[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(data[i]&lt;rightMin[i+<span class="number">1</span>])&#123;</span><br><span class="line">            rightMin[i] = data[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            rightMin[i] = rightMin[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lMax = data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(data[i]&gt;lMax &amp;&amp; data[i]&lt;rightMin[i+<span class="number">1</span>])&#123;</span><br><span class="line">            result.push_back(data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lMax&lt;data[i])&#123;</span><br><span class="line">            lMax = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>两数相加，两个正序存在链表中的数字相加。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">add</span><span class="params">(struct ListNode *a, struct ListNode *b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1,stack2;</span><br><span class="line">    <span class="keyword">while</span>(a!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        stack1.push(a-&gt;val);</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(b!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        stack2.push(b-&gt;val);</span><br><span class="line">        b = b-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> C = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">root</span>  = <span class="title">NULL</span>;</span><span class="comment">//= (struct ListNode *)malloc(sizeof(struct  ListNode));</span></span><br><span class="line">    <span class="keyword">while</span>(!stack1.empty() || !stack2.empty())&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">temp</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span>  <span class="title">ListNode</span>));</span></span><br><span class="line">        temp-&gt;val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!stack1.empty())&#123;</span><br><span class="line">            temp-&gt;val += stack1.top();</span><br><span class="line">            stack1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!stack2.empty())&#123;</span><br><span class="line">            temp-&gt;val += stack2.top();</span><br><span class="line">            stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;val = temp-&gt;val+C;</span><br><span class="line">        C = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;val&gt;<span class="number">9</span>)&#123;</span><br><span class="line">            C = <span class="number">1</span>;</span><br><span class="line">            temp-&gt;val = temp-&gt;val%<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;val == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,,&quot;</span>,stack1.<span class="built_in">size</span>(),stack2.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;next = root;</span><br><span class="line">        root = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="1，并查集"><a href="#1，并查集" class="headerlink" title="1，并查集"></a>1，并查集</h2><p>并查集主要涉及到两种操作，查找和归并</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pre[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unionsearch</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root! = pre[root])&#123;</span><br><span class="line">        root = pre[root];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> root1,<span class="keyword">int</span> root2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = unionsearch(root1);</span><br><span class="line">    <span class="keyword">int</span> y = unionsearch(root2);</span><br><span class="line">    pre[y] = x;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2，非递归快排"><a href="#2，非递归快排" class="headerlink" title="2，非递归快排"></a>2，非递归快排</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = l,j = r;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp; arr[j]&gt;=temp)&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;arr[%d] = %d\n&quot;</span>,i,arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp; arr[i]&lt;temp)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">            arr[j] = arr[i];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;arr[%d] = %d\n&quot;</span>,j,arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickSort2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    s.push(<span class="number">0</span>);</span><br><span class="line">    s.push(n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> r = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">int</span> l = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">int</span> temp = arr[l];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;l = %d,r = %d\n&quot;</span>,l,r);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = singleSort(arr,l,r);</span><br><span class="line">        <span class="keyword">if</span>(l&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">            s.push(l);</span><br><span class="line">            s.push(i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span>&lt;r)&#123;</span><br><span class="line">            s.push(i+<span class="number">1</span>);</span><br><span class="line">            s.push(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">23</span>,<span class="number">42</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(b,b+<span class="number">15</span>)</span></span>;</span><br><span class="line">    quickSort2(arr);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">15</span>;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,arr[i]);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3，约瑟夫环问题"><a href="#3，约瑟夫环问题" class="headerlink" title="3，约瑟夫环问题"></a>3，约瑟夫环问题</h2><p>对于n个人报数的约瑟夫环问题，报到m退出。第一个人（数组编号m-1）退出以后，以编号$ $<br>$$<br>F(N,M) = (F(N-1,M)+M)%N<br>$$</p>
<h2 id="4，哈希与哈希冲突"><a href="#4，哈希与哈希冲突" class="headerlink" title="4，哈希与哈希冲突"></a>4，哈希与哈希冲突</h2><ul>
<li>开放定址法<ul>
<li>当冲突发生时，使用某种探测技术在散列表中形成一个探测序列。沿此序列逐个单元地查找，直到找到给定的关键字，或者碰到一个开放的地址（即该地址单元为空）为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。查找时探测到开放的地址则表明表 中无待查的关键字，即查找失败</li>
</ul>
</li>
<li>再哈希法<ul>
<li>增加多个哈希函数</li>
</ul>
</li>
<li>链地址法<ul>
<li>每个哈希节点增加一个next指针</li>
</ul>
</li>
<li>建立公共溢出区<ul>
<li>将哈希表分为基本表和溢出表，凡是发生冲突的元素都放入溢出表</li>
</ul>
</li>
</ul>
<h2 id="5，BFS与DFS算法"><a href="#5，BFS与DFS算法" class="headerlink" title="5，BFS与DFS算法"></a>5，BFS与DFS算法</h2><ul>
<li><p>BFS（广度优先搜索）,从算法的观点，所有因为展开节点而得到的子节点都会被加进一个先进先出的队列中。一般的实验里，其邻居节点尚未被检验过的节点会被放置在一个被称为 open 的容器中（例如队列或是链表），而被检验过的节点则被放置在被称为 closed 的容器中。使用队列不使用递归计算二叉树深度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    <span class="keyword">if</span>(!pRoot) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    q.push(pRoot);</span><br><span class="line">    <span class="keyword">int</span> level=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> len=q.<span class="built_in">size</span>();</span><br><span class="line">        level++;</span><br><span class="line">        <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">            TreeNode* tem=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(tem-&gt;left) q.push(tem-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(tem-&gt;right) q.push(tem-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="6，B树，B-树，B-树"><a href="#6，B树，B-树，B-树" class="headerlink" title="6，B树，B+树，B*树"></a>6，B树，B+树，B*树</h2><ul>
<li><p>B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个）</p>
<p>（1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；</p>
<p>（2）子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且M&gt;=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；</p>
<p>（3）关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);</p>
<p>（4）所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;</p>
</li>
<li><p>B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。为什么说B+树查找的效率要比B树更高、更稳定；我们先看看两者的区别</p>
<p>（1）B+跟B树不同B+树的<strong>非叶子</strong>节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个<strong>非叶子</strong>节点所能保存的关键字大大增加；</p>
<p>（2）B+树<strong>叶子</strong>节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</p>
<p>（3）B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。</p>
<p>（4）非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）;</p>
</li>
<li><p>B*树是B+树的变种，相对于B+树他们的不同之处如下：</p>
<p>（1）首先是关键字个数限制问题，B+树初始化的关键字初始化个数是cei(m/2)，b<em>树的初始化个数为（cei(2/3</em>m)）</p>
<p>（2）B+树节点满时就会分裂，而B*树节点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来；    </p>
</li>
</ul>
<h2 id="7，KMP算法"><a href="#7，KMP算法" class="headerlink" title="7，KMP算法"></a>7，KMP算法</h2><ul>
<li><p>问题：有一个文本串S，和一个模式串P，现在要查找P在S中的位置，怎么查找呢？</p>
</li>
<li><p>步骤1：根据P构造next数组，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化过后的next 数组求法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNextval</span><span class="params">(<span class="keyword">char</span>* p, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pLen = <span class="built_in">strlen</span>(p);</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//p[k]表示前缀，p[j]表示后缀  </span></span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k])</span><br><span class="line">		&#123;</span><br><span class="line">			++j;</span><br><span class="line">			++k;</span><br><span class="line">			<span class="comment">//较之前next数组求法，改动在下面4行</span></span><br><span class="line">			<span class="keyword">if</span> (p[j] != p[k])</span><br><span class="line">				next[j] = k;   <span class="comment">//之前只有这一行</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="comment">//因为不能出现p[j] = p[ next[j ]]，所以当出现时需要继续递归，k = next[k] = next[next[k]]</span></span><br><span class="line">				next[j] = next[k];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			k = next[k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>KMP主模块代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> sLen = <span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="keyword">int</span> pLen = <span class="built_in">strlen</span>(p);</span><br><span class="line">	<span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++    </span></span><br><span class="line">		<span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j])</span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]    </span></span><br><span class="line">			<span class="comment">//next[j]即为j所对应的next值      </span></span><br><span class="line">			j = next[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (j == pLen)</span><br><span class="line">		<span class="keyword">return</span> i - j;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="8，辗转相除法"><a href="#8，辗转相除法" class="headerlink" title="8，辗转相除法"></a>8，辗转相除法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Gcd</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> M,<span class="keyword">unsigned</span> <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> Rem;</span><br><span class="line">    <span class="keyword">while</span>(N &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Rem = M % N;</span><br><span class="line">        M = N;</span><br><span class="line">        N = Rem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a，<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">        <span class="built_in">std</span>::swap(a, b);</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9，二叉树的遍历"><a href="#9，二叉树的遍历" class="headerlink" title="9，二叉树的遍历"></a>9，二叉树的遍历</h2><ul>
<li><p>前序遍历：先访问根节点，在访问左子节点，最后访问右子节点。</p>
</li>
<li><p>中序遍历：先访问左子节点，在访问根节点，最后访问右子节点。</p>
</li>
<li><p>后序遍历：先访问左子节点，在访问右子节点，最后访问根节点。</p>
</li>
<li><p>重建二叉树：前序遍历的第一个是根节点，找到中序遍历数组中的该数字得到跟节点左侧和右侧数组的长度，然后将前序遍历数组分开，递归调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="comment">//TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">ConstructCore</span><span class="params">(<span class="keyword">int</span>* startPreorder, <span class="keyword">int</span>* endPreorder,<span class="keyword">int</span>* startInorder,<span class="keyword">int</span>* endInorder)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootValue = startPreorder[<span class="number">0</span>];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode();</span><br><span class="line">    root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">    root-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    root-&gt;val = rootValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(startPreorder == endPreorder)&#123;</span><br><span class="line">        <span class="keyword">if</span>(startInorder == endInorder &amp;&amp; *startPreorder == *endPreorder)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* rootInorder = startInorder;</span><br><span class="line">    <span class="keyword">while</span>(rootInorder&lt;=endInorder &amp;&amp; *rootInorder!=rootValue)</span><br><span class="line">        ++rootInorder;</span><br><span class="line">    <span class="keyword">int</span> leftLength = rootInorder-startInorder;</span><br><span class="line">    <span class="keyword">int</span>* leftPreOrderEnd = startPreorder+leftLength;</span><br><span class="line">    <span class="keyword">if</span>(leftLength&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        root-&gt;left = ConstructCore(startPreorder+<span class="number">1</span>,leftPreOrderEnd,startInorder,startInorder+leftLength);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(leftLength&lt;endPreorder-startPreorder)&#123;</span><br><span class="line">        root-&gt;right = ConstructCore(leftPreOrderEnd+<span class="number">1</span>,endPreorder,rootInorder+<span class="number">1</span>,endInorder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">Construct</span><span class="params">(<span class="keyword">int</span>* preorder,<span class="keyword">int</span>* inorder,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preorder == <span class="literal">nullptr</span> || inorder == <span class="literal">nullptr</span> || length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ConstructCore(preorder,preorder+length<span class="number">-1</span>,inorder,inorder+length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="10，回溯法"><a href="#10，回溯法" class="headerlink" title="10，回溯法"></a>10，回溯法</h2><ul>
<li>回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</li>
</ul>
<h2 id="11，最小生成树算法"><a href="#11，最小生成树算法" class="headerlink" title="11，最小生成树算法"></a>11，最小生成树算法</h2><ul>
<li>图与图的相关定义<ul>
<li>连通图：在无向图中，若任意两个定点vi与vj中都有路径相通，则称该图为连通图</li>
<li>强连通图：在有向图中，若任意两个定点vi与vj都有路径相通，则称该有向图为强连通图。</li>
<li>连通网：在连通图中，拖图的边具有一定的意义，每一条边都对应一个数，称为权，权代表着连接连个顶点的代价，称这种连通图叫做连通网</li>
<li>生成树：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。</li>
<li>最下生成树：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment">CSDN 勿在浮沙筑高台 http://blog.csdn.net/luoshixian099算法导论--最小生成树（Prim、Kruskal）2016年7月14日</span></span><br><span class="line"><span class="comment">************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITE 0xFFFFFFFF   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VertexData unsigned int  <span class="comment">//顶点数据</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UINT  unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vexCounts 6  <span class="comment">//顶点数量</span></span></span><br><span class="line"><span class="keyword">char</span> vextex[] = &#123; <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VertexData data;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lowestcost;</span><br><span class="line">&#125;closedge[vexCounts]; <span class="comment">//Prim算法中的辅助信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VertexData u;</span><br><span class="line">    VertexData v;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> cost;  <span class="comment">//边的代价</span></span><br><span class="line">&#125;Arc;  <span class="comment">//原始图的边信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjMatrix</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> adjMat[][vexCounts])</span>  <span class="comment">//邻接矩阵表示法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vexCounts; i++)   <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vexCounts; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            adjMat[i][j] = INFINITE;</span><br><span class="line">        &#125;</span><br><span class="line">    adjMat[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">6</span>; adjMat[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">1</span>; adjMat[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">5</span>;</span><br><span class="line">    adjMat[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">6</span>; adjMat[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">5</span>; adjMat[<span class="number">1</span>][<span class="number">4</span>] = <span class="number">3</span>;</span><br><span class="line">    adjMat[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1</span>; adjMat[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">5</span>; adjMat[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">5</span>; adjMat[<span class="number">2</span>][<span class="number">4</span>] = <span class="number">6</span>; adjMat[<span class="number">2</span>][<span class="number">5</span>] = <span class="number">4</span>;</span><br><span class="line">    adjMat[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">5</span>; adjMat[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">5</span>; adjMat[<span class="number">3</span>][<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line">    adjMat[<span class="number">4</span>][<span class="number">1</span>] = <span class="number">3</span>; adjMat[<span class="number">4</span>][<span class="number">2</span>] = <span class="number">6</span>; adjMat[<span class="number">4</span>][<span class="number">5</span>] = <span class="number">6</span>;</span><br><span class="line">    adjMat[<span class="number">5</span>][<span class="number">2</span>] = <span class="number">4</span>; adjMat[<span class="number">5</span>][<span class="number">3</span>] = <span class="number">2</span>; adjMat[<span class="number">5</span>][<span class="number">4</span>] = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Minmum</span><span class="params">(struct node * closedge)</span>  <span class="comment">//返回最小代价边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">min</span> = INFINITE;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vexCounts;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (closedge[i].lowestcost &lt; <span class="built_in">min</span> &amp;&amp; closedge[i].lowestcost !=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">min</span> = closedge[i].lowestcost;</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MiniSpanTree_Prim</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> adjMat[][vexCounts], VertexData s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vexCounts;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        closedge[i].lowestcost = INFINITE;</span><br><span class="line">    &#125;      </span><br><span class="line">    closedge[s].data = s;      <span class="comment">//从顶点s开始</span></span><br><span class="line">    closedge[s].lowestcost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vexCounts;i++)  <span class="comment">//初始化辅助数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != s)</span><br><span class="line">        &#123;</span><br><span class="line">            closedge[i].data = s;</span><br><span class="line">            closedge[i].lowestcost = adjMat[s][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = <span class="number">1</span>; e &lt;= vexCounts <span class="number">-1</span>; e++)  <span class="comment">//n-1条边时退出</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = Minmum(closedge);  <span class="comment">//选择最小代价边</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; vextex[closedge[k].data] &lt;&lt; <span class="string">&quot;--&quot;</span> &lt;&lt; vextex[k] &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//加入到最小生成树</span></span><br><span class="line">        closedge[k].lowestcost = <span class="number">0</span>; <span class="comment">//代价置为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vexCounts;i++)  <span class="comment">//更新v中顶点最小代价边信息</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( adjMat[k][i] &lt; closedge[i].lowestcost)</span><br><span class="line">            &#123;</span><br><span class="line">                closedge[i].data = k;</span><br><span class="line">                closedge[i].lowestcost = adjMat[k][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReadArc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>  adjMat[][vexCounts],<span class="built_in">vector</span>&lt;Arc&gt; &amp;vertexArc)</span> <span class="comment">//保存图的边代价信息</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Arc * temp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vexCounts;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (adjMat[i][j]!=INFINITE)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = <span class="keyword">new</span> Arc;</span><br><span class="line">                temp-&gt;u = i;</span><br><span class="line">                temp-&gt;v = j;</span><br><span class="line">                temp-&gt;cost = adjMat[i][j];</span><br><span class="line">                vertexArc.push_back(*temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(Arc  A, Arc  B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.cost &lt; B.cost ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FindTree</span><span class="params">(VertexData u, VertexData v,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;VertexData&gt; &gt; &amp;Tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> index_u = INFINITE;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> index_v = INFINITE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Tree.<span class="built_in">size</span>();i++)  <span class="comment">//检查u,v分别属于哪颗树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(Tree[i].<span class="built_in">begin</span>(), Tree[i].<span class="built_in">end</span>(), u) != Tree[i].<span class="built_in">end</span>())</span><br><span class="line">            index_u = i;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(Tree[i].<span class="built_in">begin</span>(), Tree[i].<span class="built_in">end</span>(), v) != Tree[i].<span class="built_in">end</span>())</span><br><span class="line">            index_v = i;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (index_u != index_v)   <span class="comment">//u,v不在一颗树上，合并两颗树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Tree[index_v].<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Tree[index_u].push_back(Tree[index_v][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Tree[index_v].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MiniSpanTree_Kruskal</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> adjMat[][vexCounts])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Arc&gt; vertexArc;</span><br><span class="line">    ReadArc(adjMat, vertexArc);<span class="comment">//读取边信息</span></span><br><span class="line">    sort(vertexArc.<span class="built_in">begin</span>(), vertexArc.<span class="built_in">end</span>(), compare);<span class="comment">//边按从小到大排序</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;VertexData&gt; &gt; <span class="title">Tree</span><span class="params">(vexCounts)</span></span>; <span class="comment">//6棵独立树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vexCounts; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Tree[i].push_back(i);  <span class="comment">//初始化6棵独立树的信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexArc.<span class="built_in">size</span>(); i++)<span class="comment">//依次从小到大取最小代价边</span></span><br><span class="line">    &#123;</span><br><span class="line">        VertexData u = vertexArc[i].u;  </span><br><span class="line">        VertexData v = vertexArc[i].v;</span><br><span class="line">        <span class="keyword">if</span> (FindTree(u, v, Tree))<span class="comment">//检查此边的两个顶点是否在一颗树内</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; vextex[u] &lt;&lt; <span class="string">&quot;---&quot;</span> &lt;&lt; vextex[v] &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//把此边加入到最小生成树中</span></span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  adjMat[vexCounts][vexCounts] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    AdjMatrix(adjMat);   <span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Prim :&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    MiniSpanTree_Prim(adjMat,<span class="number">0</span>); <span class="comment">//Prim算法，从顶点0开始.</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;Kruskal:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    MiniSpanTree_Kruskal(adjMat);<span class="comment">//Kruskal算法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="12，红黑树"><a href="#12，红黑树" class="headerlink" title="12，红黑树"></a>12，红黑树</h2><ul>
<li>可以在O(log n)的时间内查找，插入和删除</li>
<li>特征：<ul>
<li>节点是红色或者黑色</li>
<li>根节点是黑色</li>
<li>所有叶子都是黑色</li>
<li>每个红色节点的两个子节点都是黑色</li>
<li>从任意节点到每个叶子节点的所有路径都包含相同数目的黑色节点</li>
</ul>
</li>
<li>节点插入算法：</li>
<li>节点删除算法：</li>
</ul>
<h2 id="13，堆与堆排序的实现"><a href="#13，堆与堆排序的实现" class="headerlink" title="13，堆与堆排序的实现"></a>13，堆与堆排序的实现</h2><ul>
<li><p>用大顶堆算法解决top k问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TopK_Heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.<span class="built_in">size</span>()&lt;=k)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; box;</span><br><span class="line">        box.resize(k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            box[i]=arr[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=box.<span class="built_in">size</span>()/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">            HeapAdjust(box,i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;arr.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;box[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                box[<span class="number">0</span>]=arr[i];</span><br><span class="line">                HeapAdjust(box,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;box.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;box[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*pos+<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i=<span class="number">2</span>*i+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>&amp;&amp;nums[i]&gt;nums[i+<span class="number">1</span>])</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;=nums[pos])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap(nums[i],nums[pos]);</span><br><span class="line">            pos=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="14，出栈顺序问题"><a href="#14，出栈顺序问题" class="headerlink" title="14，出栈顺序问题"></a>14，出栈顺序问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(pushV.<span class="built_in">size</span>()!= popV.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1&lt;pushV.<span class="built_in">size</span>())&#123;<span class="comment">//遍历pushV</span></span><br><span class="line">           s.push(pushV[p1]);<span class="comment">//将元素压入栈s中</span></span><br><span class="line">           <span class="keyword">if</span>(pushV[p1]==popV[p2])&#123;<span class="comment">//如果p1和p2元素相同，然后弹栈</span></span><br><span class="line">               <span class="keyword">while</span>(!s.empty()&amp;&amp; popV[p2]==s.top())&#123;</span><br><span class="line">                    s.pop();</span><br><span class="line">                    ++p2;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           ++p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="15，链表快排"><a href="#15，链表快排" class="headerlink" title="15，链表快排"></a>15，链表快排</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(ListNode *head,ListNode * <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head == <span class="built_in">end</span>)<span class="keyword">return</span>;</span><br><span class="line">        ListNode *p = head-&gt;next;</span><br><span class="line">        ListNode *small = head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val &lt; head-&gt;val)&#123;</span><br><span class="line">                small = small-&gt;next;</span><br><span class="line">                <span class="keyword">int</span> t = small-&gt;val;</span><br><span class="line">                small-&gt;val = p-&gt;val;</span><br><span class="line">                p-&gt;val = t;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t = small-&gt;val;</span><br><span class="line">        small-&gt;val = head-&gt;val;</span><br><span class="line">        head-&gt;val = t;</span><br><span class="line">        quickSort(head,small);</span><br><span class="line">        quickSort(small-&gt;next,<span class="built_in">end</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="16，topK问题"><a href="#16，topK问题" class="headerlink" title="16，topK问题"></a>16，topK问题</h2><p>大顶堆解法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TopK_Heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.<span class="built_in">size</span>()&lt;=k)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; box;</span><br><span class="line">        box.resize(k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            box[i]=arr[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=box.<span class="built_in">size</span>()/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">            HeapAdjust(box,i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;arr.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;box[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                box[<span class="number">0</span>]=arr[i];</span><br><span class="line">                HeapAdjust(box,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;box.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;box[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*pos+<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i=<span class="number">2</span>*i+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>&amp;&amp;nums[i]&gt;nums[i+<span class="number">1</span>])</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;=nums[pos])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap(nums[i],nums[pos]);</span><br><span class="line">            pos=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="17，归并排序链表"><a href="#17，归并排序链表" class="headerlink" title="17，归并排序链表"></a>17，归并排序链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* pre = head, *slow = head, *fast = head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        pre = slow;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> mergeTwoList(sortList(head), sortList(slow));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeTwoList</span><span class="params">(ListNode* h1, ListNode* h2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!h1) <span class="keyword">return</span> h2;</span><br><span class="line">    <span class="keyword">if</span>(!h2) <span class="keyword">return</span> h1;</span><br><span class="line">    <span class="keyword">if</span>(h1-&gt;val &lt; h2-&gt;val) &#123;</span><br><span class="line">        h1-&gt;next = mergeTwoList(h1-&gt;next, h2);</span><br><span class="line">        <span class="keyword">return</span> h1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        h2-&gt;next = mergeTwoList(h1, h2-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> h2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/22/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" data-id="cke858f5z0007r2fi04121tdw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-操作系统" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time datetime="2020-08-22T08:52:55.572Z" itemprop="datePublished">2020-08-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统（自整理）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h5><ul>
<li>进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</li>
<li>每个进程都有独立的代码和数据空间，程序之间的切换会有较大的开销；线程之间的切换开销小，同一类线程共享代码和数据空间，每个线程有着自己独立的运行栈和程序计数器。</li>
<li>在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</li>
</ul>
<h5 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h5><ul>
<li>无名管道（PIPE）</li>
<li>命名管道（FIFO）</li>
<li>消息队列</li>
<li>信号量</li>
<li>共享内存</li>
</ul>
<h5 id="CFS调度策略"><a href="#CFS调度策略" class="headerlink" title="CFS调度策略"></a>CFS调度策略</h5><ul>
<li><p>O(n)调度：在每次进程切换时，内核依次扫描就绪队列上的每一个进程，计算每个进程的优先级，再选择出优先级最高的进程来运行。</p>
</li>
<li><p>O(1)调度：其基本思想是根据进程的优先级进行调度。进程有两个优先级,一个是静态优先级,一个是动态优先级.静态优先级是用来计算进程运行的时间片长度的,动态优先级是在调度器进行调度时用到的,调度器每次都选取动态优先级最高的进程运行。</p>
</li>
<li><p>CFS调度：不计算优先级，而是通过计算进程消耗的CPU时间（标准化以后的虚拟CPU时间）来确定调度</p>
<ul>
<li><p>绝对公平性：将CPU当做一种资源，调度时总选择消耗资源最少的进程，这就是所谓的完全公平。但不同重要性的进程的优先级会比较高，故而我们希望能按照权重来重新分配CPU资源。</p>
</li>
<li><p>相对公平性：根据不同进程的权重分配时间。运行时间的计算公式为：分配给进程的运行时间 = 调度周期 * 进程权重 / 所有进程权重之和</p>
</li>
<li><p>linux通过引入virtual runtime（vruntime）来完成上述设想。具体我们可以看下列公式：</p>
<p>​    vruntime = 实际运行时间 * 1024 / 进程权重 。</p>
<p>实际上vruntime就是根据权重将实际运行时间标准化，标准化之后，各个进程对资源的消耗情况就可以直接通过比较vruntime来知道，比如某个进程的vruntime比较小，我们就可以知道这个进程消耗CPU资源比较少，反之消耗CPU资源就比较多。然后就调度vruntime较小的进程。</p>
</li>
</ul>
</li>
</ul>
<h5 id="死锁，同步，互斥"><a href="#死锁，同步，互斥" class="headerlink" title="死锁，同步，互斥"></a>死锁，同步，互斥</h5><ul>
<li>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</li>
<li>同步就是两个及两个以上的操作就有严格是先后顺序，其中任何一个操作依赖于另外的一个或几个操作，例如课上的例子乘务员和司机，司机是否开车依赖于乘务员是否关车门。而异步是指，几个不同的操作之间没有绝对的依赖关系。</li>
<li>临界区：把不允许多个并发进程交叉执行的一段程序称作临界区。互斥：一组并发进程中的一个或多个程序段，因共享某一公有资源而导致它们必须以一个不允许交叉执行的单位执行不允许两个以上的共享该资源的进程同时进入临界区</li>
</ul>
<h5 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h5><ul>
<li>在编程中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。每个对象都对应于一个可称为” 互斥锁” 的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。</li>
</ul>
<h5 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h5><ul>
<li>乐观锁：就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。</li>
<li>悲观锁：顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</li>
<li>CAS：CAS便是乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。<br>　　CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</li>
</ul>
<h5 id="虚拟内存与物理内存"><a href="#虚拟内存与物理内存" class="headerlink" title="虚拟内存与物理内存"></a>虚拟内存与物理内存</h5><ul>
<li>物理内存，就是运行内存。就是指计算机的安装内存“通俗的讲就是内存条的大小”</li>
<li>虚拟内存，一个进程运行时都会得到一定的虚拟内存，32位系统下是4G，进程得到的这4G虚拟内存是一个连续的地址空间（这也只是进程认为），而实际上，它通常是被分隔成多个物理内存碎片，还有一部分存储在外部磁盘存储器上，在需要时进行数据交换。<ul>
<li>每次访问一个地址，都需要把虚拟内存转换为物理内存</li>
<li>所有进程共享这整一块物理内存，每个进程只把自己目前需要的虚拟地址空间映射到物理内存上</li>
<li>虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。</li>
</ul>
</li>
</ul>
<h5 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h5><ul>
<li>并发是多个任务交替使用CPU，同一时刻还是只有一个任务在跑，并行是多个任务同时跑</li>
</ul>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><ul>
<li><p>死锁产生的条件：</p>
<p>（一）互斥条件：一个资源一次只能被一个进程访问。即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占 有。这种独占资源如CD-ROM驱动器，打印机等等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属性所决定的。</p>
<p>（二）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。</p>
<p>（三）不剥夺条件：进程已经获得的资源，在未使用完之前不能强行剥夺，而只能由该资源的占有者进程自行释放。</p>
<p>（四）循环等待条件：若干资源形成一种头尾相接的循环等待资源关系。</p>
</li>
<li><p>解决方法</p>
<ul>
<li>银行家算法</li>
</ul>
</li>
</ul>
<h5 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h5><ul>
<li>分页（英语：Paging），是一种操作系统里存储器管理的一种技术，可以使电脑的主存可以使用存储在辅助存储器中的数据。操作系统会将辅助存储器（通常是磁盘）中的数据分区成固定大小的区块，称为“页”（pages）。当不需要时，将分页由主存（通常是内存）移到辅助存储器；当需要时，再将数据取回，加载主存中。相对于分段，分页允许存储器存储于不连续的区块以维持文件系统的整齐。分页是磁盘和内存间传输数据块的最小单位。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" data-id="cke858f5r0005r2fi3mzv59vk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-os" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/22/os/" class="article-date">
  <time datetime="2020-08-22T08:52:55.520Z" itemprop="datePublished">2020-08-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/22/os/">操作系统，华中科技大学MOOC笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h5><ul>
<li>负责为应用程序分配和调度软硬件资源    </li>
<li>进程管理</li>
<li>内存管理</li>
<li>设备管理</li>
<li>文件管理</li>
</ul>
<h5 id="操作系统逻辑结构"><a href="#操作系统逻辑结构" class="headerlink" title="操作系统逻辑结构"></a>操作系统逻辑结构</h5><ul>
<li>操作系统 = 微内核+核外服务器</li>
</ul>
<h5 id="CPU的态"><a href="#CPU的态" class="headerlink" title="CPU的态"></a>CPU的态</h5><ul>
<li>CPU态（Mode）：CPU工作状态，对资源，指令的描述</li>
<li>核态，全部资源</li>
<li>用户态：能访问部分资源，用户程序</li>
<li>管态：核态和用户态之间</li>
<li>主存和辅存：主存能够直接和CPU交换信息，辅存不能，半导体存储器常做主存</li>
<li>实际存储体系：寄存器，高速缓存，主存，辅存。</li>
</ul>
<h5 id="操作系统启动过程"><a href="#操作系统启动过程" class="headerlink" title="操作系统启动过程"></a>操作系统启动过程</h5><ul>
<li>实模式-&gt;保护模式</li>
<li>BIOS 固件（firmware）功能：启动配置，提供基本I/O服务，加电自检和自举</li>
<li>POST-&gt;CMOS设置（硬盘启动）-&gt;读取MBR-&gt;控制权交给MBR-&gt;MBR读取分区表-&gt;PBR控制后面的引导过程。</li>
<li>初始引导：把OS核心装入内存，并使之开始工作接管计算机系统<ul>
<li>最常用的引导程序:grub</li>
</ul>
</li>
<li>Windows启动过程<ul>
<li>POST：加电后ＢＩＯＳ启动主机自检程序。</li>
<li>初始引导：BIOS从MBR读入引导程序，引导程序启动DOS7.0,调入操作系统核心。Windows接管系统</li>
<li>核心初始化，系统初始化</li>
</ul>
</li>
<li>Linux启动过程<ul>
<li>POST</li>
<li>MBR</li>
<li>KERNEL映像自解压并执行</li>
<li>内核初始化</li>
<li>内核启动</li>
<li>内核完成引导后，加载init程序，进程号1，init进程通过/etc/inittable脚本进行初始化</li>
</ul>
</li>
</ul>
<h5 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h5><ul>
<li>指操作系统给的服务，运行于核态，每个系统调用具有唯一标号。</li>
</ul>
<h5 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h5><ul>
<li>进程的特征:动态性，并发性，异步性，独立性（系统分配资源和调度CPU的单位）</li>
<li>进程的状态：<ul>
<li>运行状态：在运行</li>
<li>就绪状态：具备运行条件但没有CPU运行</li>
<li>阻塞状态：等待指令开始运行</li>
</ul>
</li>
<li>进程控制块（PCB）<ul>
<li>描述进程状态的数据结构</li>
<li>PCB是进程的标志，生命周期随着进程变化</li>
<li>进程 = 程序+PCB</li>
</ul>
</li>
<li>原语<ul>
<li>由若干指令构成的具有特定功能的函数</li>
<li>具有原子性，不可分割</li>
<li>进程控制原语：创建原语，撤销原语，阻塞原语，唤醒原语</li>
</ul>
</li>
<li>Linux进程控制<ul>
<li>pid_t fork()<ul>
<li>新进程是当前进程的子进程</li>
<li>子进程与父进程有着相同的代码空间，堆栈，等，还可以并发运行</li>
<li>Linux所有进程都是由fork创建（除了init），</li>
<li>exec：功能，装入一个指定的可执行程序运行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h5><ul>
<li>忙则等待：当临界区忙时，其他进程必须在临界区外等待</li>
<li>空闲让进：当无进程处于临界区，任何有权进程可进入临界区</li>
</ul>
<ul>
<li>有限等待：进程进入临界区的请求必须在有限时间内得到满足</li>
<li>让权等待：等待进程放弃CPU</li>
</ul>
<h5 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h5><ul>
<li>基本原理：<ul>
<li>设置一个“标志”表明是否可用</li>
</ul>
</li>
</ul>
<h5 id="P—V操作"><a href="#P—V操作" class="headerlink" title="P—V操作"></a>P—V操作</h5><ul>
<li><p>S指的是信号量，Q指的是进程队列</p>
</li>
<li><p>P操作，P(S,Q)</p>
<ul>
<li>S减一，S就是差</li>
<li>若差大于0，该进程继续</li>
<li>若差小鱼0，则该进程阻塞并加入到进程队列里面，转调度函数</li>
<li>进程调用P操作可能会使进程阻塞</li>
</ul>
</li>
<li><p>V操作，</p>
<ul>
<li>S值加1，为和</li>
<li>若和大于0，则该进程继续</li>
<li>若和小于等于0，则该进程继续同时从q中唤醒一个进程</li>
<li>V操作可能会唤醒被阻塞的进程</li>
</ul>
</li>
</ul>
<h5 id="linux进程同步机制"><a href="#linux进程同步机制" class="headerlink" title="linux进程同步机制"></a>linux进程同步机制</h5><ul>
<li>wait函数，<ul>
<li>阻塞自己，直到子进程结束，然后手机子进程信息并销毁子进程</li>
</ul>
</li>
<li>exit函数，<ul>
<li>释放资源并报告父进程</li>
<li>利用status传递进程结束的状态</li>
<li>变为僵尸状态，保留部分PCB信息供wait收集<ul>
<li>是否正常结束，占用CPU时间，缺页中断次数</li>
</ul>
</li>
<li>调用schedule函数</li>
</ul>
</li>
<li>父子进程共享普通变量，但互不影响</li>
<li>父子进程共享文件资源，且处理的是同一个文件资源</li>
</ul>
<h5 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h5><ul>
<li>管道是进程间的一种通信机制，一个进程（A)可以通过管道把数据传输给另一个进程，另一个进程从管道读取数据</li>
<li>匿名管道是单向的</li>
<li>管道需要重定向才能读取</li>
</ul>
<h5 id="linux信号通信"><a href="#linux信号通信" class="headerlink" title="linux信号通信"></a>linux信号通信</h5><ul>
<li>可以通过修改信号处理函数更改程序结束后的</li>
</ul>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><ul>
<li>定义:两个或者多个进程无限期等待永远不会发生的一种系统状态</li>
<li>死锁的起因：系统资源有限，并发进程的推进顺序不当】</li>
<li>必要条件：<ul>
<li>互斥条件：进程互斥使用资源，资源具有独占性（破坏难度高）</li>
<li>不剥夺条件：进程在访问完资源前不能被其他进程强行剥夺</li>
<li>部分分配条件：进程边运行边申请条件，临时需要临时分配</li>
<li>环路条件:多个进程构成环路，环中每个进程已占用的资源被前一进程申请，自己申请的资源被后一进程占用</li>
</ul>
</li>
<li>银行家算法</li>
<li>检测和恢复死锁：实现难度大，恢复方法靠人工，撤销一些进程</li>
<li>预先静态分配法：进程运行前一次性把资源全部分配<ul>
<li>执行可能延迟</li>
<li>应用开销增大</li>
<li>资源利用率低</li>
</ul>
</li>
<li>有序资源分配法<ul>
<li>每个资源有唯一一个序号</li>
<li>每次申请资源只能申请序号更大的资源</li>
</ul>
</li>
<li>Windows和Linux没有采用死锁解决方案（鸵鸟策略）</li>
</ul>
<h4 id="内存管理功能"><a href="#内存管理功能" class="headerlink" title="内存管理功能"></a>内存管理功能</h4><ul>
<li><p>实际存储器体系</p>
<ul>
<li>CPU</li>
<li>Cache（快，小，贵，在CPU内）+内存（适中）+辅存（慢，大，廉）</li>
<li>内存：RAM，就是CPU的容量</li>
</ul>
</li>
<li><p>存储管理的功能</p>
<ul>
<li>地址映射：地址重定位<ul>
<li>固定地址映射：编程或者编译时确定逻辑地址和物理地址的映射关系。容易产生冲突</li>
<li>静态地址映射：程序装入时由操作系统完成逻辑地址到物理地址映射的过程。</li>
<li>动态地址映射：在程序执行过程中把逻辑地址转换为物理地址</li>
</ul>
</li>
<li>虚拟内存<ul>
<li>虚拟内存是面向用户的虚拟封闭储存空间：在32位系统容量4G，是线性地址空间。</li>
<li>使得的程序能在较小的内存中运行</li>
<li>使得多个程序能在较小的内存中运行</li>
<li>多个程序并发运行时地址不冲突</li>
<li>内存利用效率高：无碎片，共享方便</li>
</ul>
</li>
<li>内存分配功能</li>
<li>存储保护功能<ul>
<li>防止访问越界</li>
<li>防止访问越权</li>
<li>方法：界止寄存器</li>
</ul>
</li>
</ul>
</li>
<li><p>物理内存管理</p>
<ul>
<li>分区存储管理<ul>
<li>单一区存储管理</li>
<li>固定分区，固定的划分为若干大小不等的分区</li>
<li>动态分区</li>
</ul>
</li>
<li>分区的分配<ul>
<li>从空闲区表的第一个区开始，寻找符合要求的空闲区</li>
<li>分割空闲区一般从底部分割，保证顶部的寻址地址不变，便于更新空闲区表</li>
<li>空闲区表如何排序：<ul>
<li>放置策略，</li>
<li>按空闲区位置（地址）递增排序，按空闲区</li>
<li>最佳适应法，空闲区表按大小递增排序，以求尽可能先使用较小的空闲区，保留大的</li>
<li>最快适应法：能够最快的找到合适的空闲区，</li>
</ul>
</li>
</ul>
</li>
<li>覆盖——overlay<ul>
<li>目的，在较小的内存空间中运行较大的程序</li>
<li>内存分区：常驻区，覆盖区（可以被多段程序利用）</li>
<li>效率低，从外存装入内存耗时</li>
</ul>
</li>
<li>交换技术——Swapping<ul>
<li>内存不够时把进程写到磁盘</li>
<li>当进程要运行时重新协会内存</li>
</ul>
</li>
<li>内存碎片<ul>
<li>过小的空闲区无法处理</li>
<li>动态分区的缺点：内存的反复分配和分割，产生内存碎片</li>
<li>解决方法：<ul>
<li>规定门限：若剩下的部分小于门限，则不作分割</li>
<li>内存拼接技术：</li>
<li>解除程序占用连续内存才能运行的限制</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>虚拟内存管理</p>
<ul>
<li>大的程序能在小的内存中运行</li>
<li>多个程序在较小的内存中运行</li>
<li>多个程序并发时地址不冲突</li>
<li>提高利用率，无碎片内存</li>
</ul>
</li>
<li><p>页式内存管理</p>
<ul>
<li>把进程空间（虚拟）和内存空间划成等大小的小片<ul>
<li>进程小片：页</li>
<li>内存小片：页框</li>
</ul>
</li>
<li>页表<ul>
<li>虚拟（VA）地址可以分解为页号P和页内便宜W</li>
<li>页号 = VA/页的大小，偏移 = VA%页的大小</li>
<li>页面映射表：记录页与页框之间的对应关系。也叫页表</li>
</ul>
</li>
<li>页式地址映射<ul>
<li>功能：虚拟地址-&gt;物理地址</li>
<li>过程：分离P和W，查页表，计算物理地址MA</li>
</ul>
</li>
</ul>
</li>
<li><p>快表（Cache）</p>
<ul>
<li>慢表：页表放在内存中</li>
<li>快表：页表放在Cache中</li>
<li>块表的特点：<ul>
<li>容量小，访问快，成本高</li>
<li>块表是慢表中部分内容的复制</li>
<li>地址映射优先访问块表：若在块表中找到所需数据，则称为“命中”，没有命中，则访问慢表并更新快表</li>
</ul>
</li>
</ul>
</li>
<li><p>页面的共享</p>
<ul>
<li>一个程序分为代码段和数据段，代码段可以共享</li>
<li>在不同进程的页表中天上相同的页框号，多个进程能访问相同的内存空间，从而实现页面共享</li>
<li>共享页面在内存中只有一份真实储存，节省内存</li>
</ul>
</li>
<li><p>缺页中断</p>
<ul>
<li>页表扩充——带中断位的页表</li>
<li>页表扩充——带访问位和修改位的页表</li>
<li>概念：当所要访问的目的页不在内存中时，则系统产生异常中断——缺页中断</li>
<li>缺页中断处理程序：中断处理程序把所缺的页从页表指出的辅存地址调入内存的某个页框中，并更新页表中该页对应的页框号以及修改中断位I为0</li>
</ul>
</li>
<li><p>页面淘汰策略</p>
<ul>
<li>缺页中断时装入新的页面时要淘汰页</li>
<li>页面抖动：页面在内存和辅存间频繁交换的现象，是IO操作，会降低系统效率</li>
<li>OPT算法（最佳算法）：淘汰不再需要或最远的将来才会用到的页面</li>
<li>FIFO算法（先进先出淘汰算法）</li>
<li>LRU算法（淘汰最长时间未被使用的页面）</li>
<li>LFU算法（最不经常使用算法）</li>
</ul>
</li>
<li><p>缺页因素</p>
<ul>
<li>淘汰算法</li>
<li>页框越少，越容易缺页</li>
<li>页面大小：页面太大：浪费内存。页面太小：页表长度增加，浪费内存，同时换页频繁，浪费效率</li>
</ul>
</li>
<li><p>进程分段</p>
<ul>
<li>进程按逻辑意义分为多个段，每段有段名，长度不定，进程有多段组成</li>
<li>段式内存管理系统的内存分配<ul>
<li>以段为单位装入，每段分配连续的内存，段和段之间不要求相邻</li>
<li>段式虚拟内存VA包含段号S和段内偏移W</li>
</ul>
</li>
<li>段表（SMT）：记录段，内存，地址的映射关系</li>
<li>段的优点：页面不方便共享，段方便共享</li>
<li>段页式存储管理<ul>
<li>在段中划分页面——段号-页号-页内偏移</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/22/os/" data-id="cke858f5p0004r2fi9xngc461" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/22/gcc%E6%8C%87%E4%BB%A4%E5%8F%82%E6%95%B0%E9%9B%86%E5%90%88/">gcc指令参数集</a>
          </li>
        
          <li>
            <a href="/2020/08/22/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Linux常用命令</a>
          </li>
        
          <li>
            <a href="/2020/08/22/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">语言学习笔记</a>
          </li>
        
          <li>
            <a href="/2020/08/22/%E9%80%9A%E8%AE%AF%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/">通信原理与计算机网络</a>
          </li>
        
          <li>
            <a href="/2020/08/22/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">算法笔记与整理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>